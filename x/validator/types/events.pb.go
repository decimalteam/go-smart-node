// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: decimal/validator/v1/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventCreateValidator defines event emitted when new validator is created.
type EventCreateValidator struct {
	Sender          string                                 `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Validator       string                                 `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	RewardAddress   string                                 `protobuf:"bytes,3,opt,name=reward_address,json=rewardAddress,proto3" json:"reward_address,omitempty"`
	ConsensusPubkey string                                 `protobuf:"bytes,4,opt,name=consensus_pubkey,json=consensusPubkey,proto3" json:"consensus_pubkey,omitempty"`
	Description     Description                            `protobuf:"bytes,5,opt,name=description,proto3" json:"description"`
	Commission      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=commission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"commission"`
	Stake           types.Coin                             `protobuf:"bytes,7,opt,name=stake,proto3" json:"stake"`
}

func (m *EventCreateValidator) Reset()         { *m = EventCreateValidator{} }
func (m *EventCreateValidator) String() string { return proto.CompactTextString(m) }
func (*EventCreateValidator) ProtoMessage()    {}
func (*EventCreateValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{0}
}
func (m *EventCreateValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreateValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreateValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreateValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreateValidator.Merge(m, src)
}
func (m *EventCreateValidator) XXX_Size() int {
	return m.Size()
}
func (m *EventCreateValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreateValidator.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreateValidator proto.InternalMessageInfo

func (m *EventCreateValidator) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventCreateValidator) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventCreateValidator) GetRewardAddress() string {
	if m != nil {
		return m.RewardAddress
	}
	return ""
}

func (m *EventCreateValidator) GetConsensusPubkey() string {
	if m != nil {
		return m.ConsensusPubkey
	}
	return ""
}

func (m *EventCreateValidator) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *EventCreateValidator) GetStake() types.Coin {
	if m != nil {
		return m.Stake
	}
	return types.Coin{}
}

// EventEditValidator defines event emitted when existing validator is editted.
type EventEditValidator struct {
	Sender        string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Validator     string      `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	RewardAddress string      `protobuf:"bytes,3,opt,name=reward_address,json=rewardAddress,proto3" json:"reward_address,omitempty"`
	Description   Description `protobuf:"bytes,4,opt,name=description,proto3" json:"description"`
}

func (m *EventEditValidator) Reset()         { *m = EventEditValidator{} }
func (m *EventEditValidator) String() string { return proto.CompactTextString(m) }
func (*EventEditValidator) ProtoMessage()    {}
func (*EventEditValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{1}
}
func (m *EventEditValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEditValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEditValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEditValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEditValidator.Merge(m, src)
}
func (m *EventEditValidator) XXX_Size() int {
	return m.Size()
}
func (m *EventEditValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEditValidator.DiscardUnknown(m)
}

var xxx_messageInfo_EventEditValidator proto.InternalMessageInfo

func (m *EventEditValidator) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventEditValidator) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEditValidator) GetRewardAddress() string {
	if m != nil {
		return m.RewardAddress
	}
	return ""
}

func (m *EventEditValidator) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

// EventSetOnline defines event emitted when existing validator is turned on into the blockchain consensus.
type EventSetOnline struct {
	Sender    string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
}

func (m *EventSetOnline) Reset()         { *m = EventSetOnline{} }
func (m *EventSetOnline) String() string { return proto.CompactTextString(m) }
func (*EventSetOnline) ProtoMessage()    {}
func (*EventSetOnline) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{2}
}
func (m *EventSetOnline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetOnline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetOnline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetOnline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetOnline.Merge(m, src)
}
func (m *EventSetOnline) XXX_Size() int {
	return m.Size()
}
func (m *EventSetOnline) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetOnline.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetOnline proto.InternalMessageInfo

func (m *EventSetOnline) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventSetOnline) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

// EventSetOffline defines event emitted when existing validator is turned off from the blockchain consensus.
type EventSetOffline struct {
	Sender    string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
}

func (m *EventSetOffline) Reset()         { *m = EventSetOffline{} }
func (m *EventSetOffline) String() string { return proto.CompactTextString(m) }
func (*EventSetOffline) ProtoMessage()    {}
func (*EventSetOffline) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{3}
}
func (m *EventSetOffline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetOffline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetOffline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetOffline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetOffline.Merge(m, src)
}
func (m *EventSetOffline) XXX_Size() int {
	return m.Size()
}
func (m *EventSetOffline) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetOffline.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetOffline proto.InternalMessageInfo

func (m *EventSetOffline) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventSetOffline) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

// EventDelegate defines event emitted when a coin or NFT is delegated to a validator.
type EventDelegate struct {
	Delegator  string                `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	Validator  string                `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	Stake      Stake                 `protobuf:"bytes,3,opt,name=stake,proto3" json:"stake"`
	AmountBase cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_base,json=amountBase,proto3,customtype=cosmossdk.io/math.Int" json:"amount_base"`
}

func (m *EventDelegate) Reset()         { *m = EventDelegate{} }
func (m *EventDelegate) String() string { return proto.CompactTextString(m) }
func (*EventDelegate) ProtoMessage()    {}
func (*EventDelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{4}
}
func (m *EventDelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDelegate.Merge(m, src)
}
func (m *EventDelegate) XXX_Size() int {
	return m.Size()
}
func (m *EventDelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDelegate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDelegate proto.InternalMessageInfo

func (m *EventDelegate) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventDelegate) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventDelegate) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

// EventRedelegate defines event emitted when a coin or NFT is redelegated from a validator to another one.
type EventRedelegate struct {
	Delegator    string                `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	ValidatorSrc string                `protobuf:"bytes,2,opt,name=validator_src,json=validatorSrc,proto3" json:"validator_src,omitempty"`
	ValidatorDst string                `protobuf:"bytes,3,opt,name=validator_dst,json=validatorDst,proto3" json:"validator_dst,omitempty"`
	Stake        Stake                 `protobuf:"bytes,4,opt,name=stake,proto3" json:"stake"`
	AmountBase   cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount_base,json=amountBase,proto3,customtype=cosmossdk.io/math.Int" json:"amount_base"`
	CompleteAt   time.Time             `protobuf:"bytes,6,opt,name=complete_at,json=completeAt,proto3,stdtime" json:"complete_at"`
}

func (m *EventRedelegate) Reset()         { *m = EventRedelegate{} }
func (m *EventRedelegate) String() string { return proto.CompactTextString(m) }
func (*EventRedelegate) ProtoMessage()    {}
func (*EventRedelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{5}
}
func (m *EventRedelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRedelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRedelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRedelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRedelegate.Merge(m, src)
}
func (m *EventRedelegate) XXX_Size() int {
	return m.Size()
}
func (m *EventRedelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRedelegate.DiscardUnknown(m)
}

var xxx_messageInfo_EventRedelegate proto.InternalMessageInfo

func (m *EventRedelegate) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventRedelegate) GetValidatorSrc() string {
	if m != nil {
		return m.ValidatorSrc
	}
	return ""
}

func (m *EventRedelegate) GetValidatorDst() string {
	if m != nil {
		return m.ValidatorDst
	}
	return ""
}

func (m *EventRedelegate) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

func (m *EventRedelegate) GetCompleteAt() time.Time {
	if m != nil {
		return m.CompleteAt
	}
	return time.Time{}
}

// EventRedelegateComplete defines event emitted when a redelegation is completed.
type EventRedelegateComplete struct {
	Delegator    string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	ValidatorSrc string `protobuf:"bytes,2,opt,name=validator_src,json=validatorSrc,proto3" json:"validator_src,omitempty"`
	ValidatorDst string `protobuf:"bytes,3,opt,name=validator_dst,json=validatorDst,proto3" json:"validator_dst,omitempty"`
	Stake        Stake  `protobuf:"bytes,4,opt,name=stake,proto3" json:"stake"`
}

func (m *EventRedelegateComplete) Reset()         { *m = EventRedelegateComplete{} }
func (m *EventRedelegateComplete) String() string { return proto.CompactTextString(m) }
func (*EventRedelegateComplete) ProtoMessage()    {}
func (*EventRedelegateComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{6}
}
func (m *EventRedelegateComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRedelegateComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRedelegateComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRedelegateComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRedelegateComplete.Merge(m, src)
}
func (m *EventRedelegateComplete) XXX_Size() int {
	return m.Size()
}
func (m *EventRedelegateComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRedelegateComplete.DiscardUnknown(m)
}

var xxx_messageInfo_EventRedelegateComplete proto.InternalMessageInfo

func (m *EventRedelegateComplete) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventRedelegateComplete) GetValidatorSrc() string {
	if m != nil {
		return m.ValidatorSrc
	}
	return ""
}

func (m *EventRedelegateComplete) GetValidatorDst() string {
	if m != nil {
		return m.ValidatorDst
	}
	return ""
}

func (m *EventRedelegateComplete) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

// EventUndelegate defines event emitted when a coin or NFT is undelegated from a validator.
type EventUndelegate struct {
	Delegator  string                `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	Validator  string                `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	Stake      Stake                 `protobuf:"bytes,3,opt,name=stake,proto3" json:"stake"`
	AmountBase cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_base,json=amountBase,proto3,customtype=cosmossdk.io/math.Int" json:"amount_base"`
	CompleteAt time.Time             `protobuf:"bytes,5,opt,name=complete_at,json=completeAt,proto3,stdtime" json:"complete_at"`
}

func (m *EventUndelegate) Reset()         { *m = EventUndelegate{} }
func (m *EventUndelegate) String() string { return proto.CompactTextString(m) }
func (*EventUndelegate) ProtoMessage()    {}
func (*EventUndelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{7}
}
func (m *EventUndelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUndelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUndelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUndelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUndelegate.Merge(m, src)
}
func (m *EventUndelegate) XXX_Size() int {
	return m.Size()
}
func (m *EventUndelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUndelegate.DiscardUnknown(m)
}

var xxx_messageInfo_EventUndelegate proto.InternalMessageInfo

func (m *EventUndelegate) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventUndelegate) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventUndelegate) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

func (m *EventUndelegate) GetCompleteAt() time.Time {
	if m != nil {
		return m.CompleteAt
	}
	return time.Time{}
}

// EventUndelegateComplete defines event emitted when a undelegation is completed.
type EventUndelegateComplete struct {
	Delegator string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	Stake     Stake  `protobuf:"bytes,3,opt,name=stake,proto3" json:"stake"`
}

func (m *EventUndelegateComplete) Reset()         { *m = EventUndelegateComplete{} }
func (m *EventUndelegateComplete) String() string { return proto.CompactTextString(m) }
func (*EventUndelegateComplete) ProtoMessage()    {}
func (*EventUndelegateComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{8}
}
func (m *EventUndelegateComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUndelegateComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUndelegateComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUndelegateComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUndelegateComplete.Merge(m, src)
}
func (m *EventUndelegateComplete) XXX_Size() int {
	return m.Size()
}
func (m *EventUndelegateComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUndelegateComplete.DiscardUnknown(m)
}

var xxx_messageInfo_EventUndelegateComplete proto.InternalMessageInfo

func (m *EventUndelegateComplete) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventUndelegateComplete) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventUndelegateComplete) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

// EventCancelRedelegation defines event emitted when a redelegated from a validator to another one is cancelled.
type EventCancelRedelegation struct {
	Delegator      string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	ValidatorSrc   string `protobuf:"bytes,2,opt,name=validator_src,json=validatorSrc,proto3" json:"validator_src,omitempty"`
	ValidatorDst   string `protobuf:"bytes,3,opt,name=validator_dst,json=validatorDst,proto3" json:"validator_dst,omitempty"`
	CreationHeight int64  `protobuf:"varint,4,opt,name=creation_height,json=creationHeight,proto3" json:"creation_height,omitempty"`
	Stake          Stake  `protobuf:"bytes,5,opt,name=stake,proto3" json:"stake"`
}

func (m *EventCancelRedelegation) Reset()         { *m = EventCancelRedelegation{} }
func (m *EventCancelRedelegation) String() string { return proto.CompactTextString(m) }
func (*EventCancelRedelegation) ProtoMessage()    {}
func (*EventCancelRedelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{9}
}
func (m *EventCancelRedelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelRedelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelRedelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelRedelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelRedelegation.Merge(m, src)
}
func (m *EventCancelRedelegation) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelRedelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelRedelegation.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelRedelegation proto.InternalMessageInfo

func (m *EventCancelRedelegation) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventCancelRedelegation) GetValidatorSrc() string {
	if m != nil {
		return m.ValidatorSrc
	}
	return ""
}

func (m *EventCancelRedelegation) GetValidatorDst() string {
	if m != nil {
		return m.ValidatorDst
	}
	return ""
}

func (m *EventCancelRedelegation) GetCreationHeight() int64 {
	if m != nil {
		return m.CreationHeight
	}
	return 0
}

func (m *EventCancelRedelegation) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

// EventCancelUndelegation defines event emitted when an undelegated from a validator is cancelled.
type EventCancelUndelegation struct {
	Delegator      string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	Validator      string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	CreationHeight int64  `protobuf:"varint,3,opt,name=creation_height,json=creationHeight,proto3" json:"creation_height,omitempty"`
	Stake          Stake  `protobuf:"bytes,4,opt,name=stake,proto3" json:"stake"`
}

func (m *EventCancelUndelegation) Reset()         { *m = EventCancelUndelegation{} }
func (m *EventCancelUndelegation) String() string { return proto.CompactTextString(m) }
func (*EventCancelUndelegation) ProtoMessage()    {}
func (*EventCancelUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{10}
}
func (m *EventCancelUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelUndelegation.Merge(m, src)
}
func (m *EventCancelUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelUndelegation proto.InternalMessageInfo

func (m *EventCancelUndelegation) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *EventCancelUndelegation) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventCancelUndelegation) GetCreationHeight() int64 {
	if m != nil {
		return m.CreationHeight
	}
	return 0
}

func (m *EventCancelUndelegation) GetStake() Stake {
	if m != nil {
		return m.Stake
	}
	return Stake{}
}

// EventUpdateValidator defines event emitted when existing validator is updated.
type EventUpdateValidator struct {
	Validator   string     `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	Status      BondStatus `protobuf:"varint,2,opt,name=status,proto3,enum=decimal.validator.v1.BondStatus" json:"status,omitempty"`
	Online      bool       `protobuf:"varint,3,opt,name=online,proto3" json:"online,omitempty"`
	Jailed      bool       `protobuf:"varint,4,opt,name=jailed,proto3" json:"jailed,omitempty"`
	VotingPower uint64     `protobuf:"varint,5,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
}

func (m *EventUpdateValidator) Reset()         { *m = EventUpdateValidator{} }
func (m *EventUpdateValidator) String() string { return proto.CompactTextString(m) }
func (*EventUpdateValidator) ProtoMessage()    {}
func (*EventUpdateValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{11}
}
func (m *EventUpdateValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUpdateValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUpdateValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUpdateValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUpdateValidator.Merge(m, src)
}
func (m *EventUpdateValidator) XXX_Size() int {
	return m.Size()
}
func (m *EventUpdateValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUpdateValidator.DiscardUnknown(m)
}

var xxx_messageInfo_EventUpdateValidator proto.InternalMessageInfo

func (m *EventUpdateValidator) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventUpdateValidator) GetStatus() BondStatus {
	if m != nil {
		return m.Status
	}
	return BondStatus_Unspecified
}

func (m *EventUpdateValidator) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *EventUpdateValidator) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *EventUpdateValidator) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

// EventDelegatedCoinsUpdate defines event emitted when total delegated amount of any coin is changed.
type EventDelegatedCoinsUpdate struct {
}

func (m *EventDelegatedCoinsUpdate) Reset()         { *m = EventDelegatedCoinsUpdate{} }
func (m *EventDelegatedCoinsUpdate) String() string { return proto.CompactTextString(m) }
func (*EventDelegatedCoinsUpdate) ProtoMessage()    {}
func (*EventDelegatedCoinsUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{12}
}
func (m *EventDelegatedCoinsUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDelegatedCoinsUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDelegatedCoinsUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDelegatedCoinsUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDelegatedCoinsUpdate.Merge(m, src)
}
func (m *EventDelegatedCoinsUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventDelegatedCoinsUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDelegatedCoinsUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDelegatedCoinsUpdate proto.InternalMessageInfo

// EventEmission defines event emitted when emission for the block is minted.
type EventEmission struct {
	Amount cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *EventEmission) Reset()         { *m = EventEmission{} }
func (m *EventEmission) String() string { return proto.CompactTextString(m) }
func (*EventEmission) ProtoMessage()    {}
func (*EventEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{13}
}
func (m *EventEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEmission.Merge(m, src)
}
func (m *EventEmission) XXX_Size() int {
	return m.Size()
}
func (m *EventEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEmission.DiscardUnknown(m)
}

var xxx_messageInfo_EventEmission proto.InternalMessageInfo

// EventPayRewards defines event emitted when all accumulated commissions are payed as rewards.
type EventPayRewards struct {
	Validators []ValidatorReward `protobuf:"bytes,1,rep,name=validators,proto3" json:"validators"`
}

func (m *EventPayRewards) Reset()         { *m = EventPayRewards{} }
func (m *EventPayRewards) String() string { return proto.CompactTextString(m) }
func (*EventPayRewards) ProtoMessage()    {}
func (*EventPayRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{14}
}
func (m *EventPayRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPayRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPayRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPayRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPayRewards.Merge(m, src)
}
func (m *EventPayRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventPayRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPayRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventPayRewards proto.InternalMessageInfo

func (m *EventPayRewards) GetValidators() []ValidatorReward {
	if m != nil {
		return m.Validators
	}
	return nil
}

// EventLiveness defines event emitted when a validator is missed a block to sign.
type EventLiveness struct {
	Validator       string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	ConsensusPubkey string `protobuf:"bytes,2,opt,name=consensus_pubkey,json=consensusPubkey,proto3" json:"consensus_pubkey,omitempty"`
	MissedBlocks    uint32 `protobuf:"varint,3,opt,name=missed_blocks,json=missedBlocks,proto3" json:"missed_blocks,omitempty"`
}

func (m *EventLiveness) Reset()         { *m = EventLiveness{} }
func (m *EventLiveness) String() string { return proto.CompactTextString(m) }
func (*EventLiveness) ProtoMessage()    {}
func (*EventLiveness) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{15}
}
func (m *EventLiveness) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLiveness) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLiveness.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLiveness) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLiveness.Merge(m, src)
}
func (m *EventLiveness) XXX_Size() int {
	return m.Size()
}
func (m *EventLiveness) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLiveness.DiscardUnknown(m)
}

var xxx_messageInfo_EventLiveness proto.InternalMessageInfo

func (m *EventLiveness) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventLiveness) GetConsensusPubkey() string {
	if m != nil {
		return m.ConsensusPubkey
	}
	return ""
}

func (m *EventLiveness) GetMissedBlocks() uint32 {
	if m != nil {
		return m.MissedBlocks
	}
	return 0
}

// EventSlash defines event emitted when a validator is slashed.
type EventSlash struct {
	Validator  string           `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	Delegators []DelegatorSlash `protobuf:"bytes,2,rep,name=delegators,proto3" json:"delegators"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{16}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventSlash) GetDelegators() []DelegatorSlash {
	if m != nil {
		return m.Delegators
	}
	return nil
}

// ValidatorReward contains the detailed validator rewards.
type ValidatorReward struct {
	// validator is the bech32-encoded address of the validator.
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// dao is the amount of the reward in base coin sent to the DAO.
	Dao cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=dao,proto3,customtype=cosmossdk.io/math.Int" json:"dao"`
	// develop is the amount of the reward in base coin sent to the Develop.
	Develop cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=develop,proto3,customtype=cosmossdk.io/math.Int" json:"develop"`
	// commission is the amount of the reward in base coin sent to the validator as it's commission.
	Commission cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=commission,proto3,customtype=cosmossdk.io/math.Int" json:"commission"`
	// accumulated is the total amount of the reward in base coin accumulated for the validator.
	Accumulated cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=accumulated,proto3,customtype=cosmossdk.io/math.Int" json:"accumulated"`
	// delegators is the complete list of delegator rewards.
	Delegators []DelegatorReward `protobuf:"bytes,6,rep,name=delegators,proto3" json:"delegators"`
}

func (m *ValidatorReward) Reset()         { *m = ValidatorReward{} }
func (m *ValidatorReward) String() string { return proto.CompactTextString(m) }
func (*ValidatorReward) ProtoMessage()    {}
func (*ValidatorReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{17}
}
func (m *ValidatorReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorReward.Merge(m, src)
}
func (m *ValidatorReward) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorReward) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorReward.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorReward proto.InternalMessageInfo

// DelegatorReward contains delegator address and amount of a reward in base coin.
type DelegatorReward struct {
	// delegator is the bech32-encoded address of the delegator.
	Delegator string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	// coins is the complete list of coin stakes rewards.
	Coins []StakeReward `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins"`
	// nfts is the complete list of NFT stakes rewards.
	NFTs []StakeReward `protobuf:"bytes,3,rep,name=nfts,proto3" json:"nfts"`
}

func (m *DelegatorReward) Reset()         { *m = DelegatorReward{} }
func (m *DelegatorReward) String() string { return proto.CompactTextString(m) }
func (*DelegatorReward) ProtoMessage()    {}
func (*DelegatorReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{18}
}
func (m *DelegatorReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorReward.Merge(m, src)
}
func (m *DelegatorReward) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorReward) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorReward.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorReward proto.InternalMessageInfo

// StakeReward contains delegator stake ID and amount of a reward in base coin.
type StakeReward struct {
	// id defines the stake ID.
	// For stake in Coin: contains coin denom value.
	// For stake in NFT: contains NFT token ID value.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// reward is the amount of the reward in base coin.
	Reward cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=reward,proto3,customtype=cosmossdk.io/math.Int" json:"reward"`
}

func (m *StakeReward) Reset()         { *m = StakeReward{} }
func (m *StakeReward) String() string { return proto.CompactTextString(m) }
func (*StakeReward) ProtoMessage()    {}
func (*StakeReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{19}
}
func (m *StakeReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeReward.Merge(m, src)
}
func (m *StakeReward) XXX_Size() int {
	return m.Size()
}
func (m *StakeReward) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeReward.DiscardUnknown(m)
}

var xxx_messageInfo_StakeReward proto.InternalMessageInfo

// ValidatorSlash contains the detailed validator slash.
type ValidatorSlash struct {
	// validator is the bech32-encoded address of the validator.
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// delegators is the complete list of delegator rewards.
	Delegators    []DelegatorSlash  `protobuf:"bytes,6,rep,name=delegators,proto3" json:"delegators"`
	Undelegations []UndelegateSlash `protobuf:"bytes,7,rep,name=undelegations,proto3" json:"undelegations"`
	Redelegations []RedelegateSlash `protobuf:"bytes,8,rep,name=redelegations,proto3" json:"redelegations"`
}

func (m *ValidatorSlash) Reset()         { *m = ValidatorSlash{} }
func (m *ValidatorSlash) String() string { return proto.CompactTextString(m) }
func (*ValidatorSlash) ProtoMessage()    {}
func (*ValidatorSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{20}
}
func (m *ValidatorSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSlash.Merge(m, src)
}
func (m *ValidatorSlash) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSlash.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSlash proto.InternalMessageInfo

// DelegatorSlash contains delegator address and amount of a reward in base coin.
type DelegatorSlash struct {
	// delegator is the bech32-encoded address of the delegator.
	Delegator string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	// coins is the list of coin slashes.
	Coins []SlashCoin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins"`
	// nfts is the list of NFT slashes.
	NFTs []SlashNFT `protobuf:"bytes,3,rep,name=nfts,proto3" json:"nfts"`
}

func (m *DelegatorSlash) Reset()         { *m = DelegatorSlash{} }
func (m *DelegatorSlash) String() string { return proto.CompactTextString(m) }
func (*DelegatorSlash) ProtoMessage()    {}
func (*DelegatorSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{21}
}
func (m *DelegatorSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorSlash.Merge(m, src)
}
func (m *DelegatorSlash) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorSlash.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorSlash proto.InternalMessageInfo

// UndelegateSlash defines event emitted when some undelegation is slashed.
type UndelegateSlash struct {
	// delegator is the bech32-encoded address of the delegator.
	Delegator string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	// validator is the bech32-encoded address of the validator.
	Validator string `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	// coins is the list of coin slashes.
	Coins []SlashCoin `protobuf:"bytes,3,rep,name=coins,proto3" json:"coins"`
	// nfts is the list of NFT slashes.
	NFTs []SlashNFT `protobuf:"bytes,4,rep,name=nfts,proto3" json:"nfts"`
}

func (m *UndelegateSlash) Reset()         { *m = UndelegateSlash{} }
func (m *UndelegateSlash) String() string { return proto.CompactTextString(m) }
func (*UndelegateSlash) ProtoMessage()    {}
func (*UndelegateSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{22}
}
func (m *UndelegateSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateSlash.Merge(m, src)
}
func (m *UndelegateSlash) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateSlash.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateSlash proto.InternalMessageInfo

// RedelegateSlash defines event emitted when some redelegation is slashed.
type RedelegateSlash struct {
	Delegator    string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	ValidatorSrc string `protobuf:"bytes,2,opt,name=validator_src,json=validatorSrc,proto3" json:"validator_src,omitempty"`
	ValidatorDst string `protobuf:"bytes,3,opt,name=validator_dst,json=validatorDst,proto3" json:"validator_dst,omitempty"`
	// coins is the list of coin slashes.
	Coins []SlashCoin `protobuf:"bytes,4,rep,name=coins,proto3" json:"coins"`
	// nfts is the list of NFT slashes.
	NFTs []SlashNFT `protobuf:"bytes,5,rep,name=nfts,proto3" json:"nfts"`
}

func (m *RedelegateSlash) Reset()         { *m = RedelegateSlash{} }
func (m *RedelegateSlash) String() string { return proto.CompactTextString(m) }
func (*RedelegateSlash) ProtoMessage()    {}
func (*RedelegateSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{23}
}
func (m *RedelegateSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedelegateSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedelegateSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedelegateSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedelegateSlash.Merge(m, src)
}
func (m *RedelegateSlash) XXX_Size() int {
	return m.Size()
}
func (m *RedelegateSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_RedelegateSlash.DiscardUnknown(m)
}

var xxx_messageInfo_RedelegateSlash proto.InternalMessageInfo

func (m *RedelegateSlash) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *RedelegateSlash) GetValidatorSrc() string {
	if m != nil {
		return m.ValidatorSrc
	}
	return ""
}

func (m *RedelegateSlash) GetValidatorDst() string {
	if m != nil {
		return m.ValidatorDst
	}
	return ""
}

func (m *RedelegateSlash) GetCoins() []SlashCoin {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *RedelegateSlash) GetNFTs() []SlashNFT {
	if m != nil {
		return m.NFTs
	}
	return nil
}

// SlashCoin contains coin slash info.
type SlashCoin struct {
	// slash is the slashed coin.
	Slash types.Coin `protobuf:"bytes,1,opt,name=slash,proto3" json:"slash"`
}

func (m *SlashCoin) Reset()         { *m = SlashCoin{} }
func (m *SlashCoin) String() string { return proto.CompactTextString(m) }
func (*SlashCoin) ProtoMessage()    {}
func (*SlashCoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{24}
}
func (m *SlashCoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashCoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashCoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashCoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashCoin.Merge(m, src)
}
func (m *SlashCoin) XXX_Size() int {
	return m.Size()
}
func (m *SlashCoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashCoin.DiscardUnknown(m)
}

var xxx_messageInfo_SlashCoin proto.InternalMessageInfo

// SlashNFT contains NFT slash info.
type SlashNFT struct {
	// id defines the slashed NFT token ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// sub_tokens defines the slashed NFT sub-tokens.
	SubTokens []SlashNFTSubToken `protobuf:"bytes,2,rep,name=sub_tokens,json=subTokens,proto3" json:"sub_tokens"`
}

func (m *SlashNFT) Reset()         { *m = SlashNFT{} }
func (m *SlashNFT) String() string { return proto.CompactTextString(m) }
func (*SlashNFT) ProtoMessage()    {}
func (*SlashNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{25}
}
func (m *SlashNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashNFT.Merge(m, src)
}
func (m *SlashNFT) XXX_Size() int {
	return m.Size()
}
func (m *SlashNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashNFT.DiscardUnknown(m)
}

var xxx_messageInfo_SlashNFT proto.InternalMessageInfo

// SlashNFTSubToken contains NFT sub-token slash info.
type SlashNFTSubToken struct {
	// id defines the NFT sub-token ID.
	ID uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// slash is the slashed NFT sub-token reserve.
	Slash types.Coin `protobuf:"bytes,2,opt,name=slash,proto3" json:"slash"`
}

func (m *SlashNFTSubToken) Reset()         { *m = SlashNFTSubToken{} }
func (m *SlashNFTSubToken) String() string { return proto.CompactTextString(m) }
func (*SlashNFTSubToken) ProtoMessage()    {}
func (*SlashNFTSubToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_060d365471b9fb1d, []int{26}
}
func (m *SlashNFTSubToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashNFTSubToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashNFTSubToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashNFTSubToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashNFTSubToken.Merge(m, src)
}
func (m *SlashNFTSubToken) XXX_Size() int {
	return m.Size()
}
func (m *SlashNFTSubToken) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashNFTSubToken.DiscardUnknown(m)
}

var xxx_messageInfo_SlashNFTSubToken proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EventCreateValidator)(nil), "decimal.validator.v1.EventCreateValidator")
	proto.RegisterType((*EventEditValidator)(nil), "decimal.validator.v1.EventEditValidator")
	proto.RegisterType((*EventSetOnline)(nil), "decimal.validator.v1.EventSetOnline")
	proto.RegisterType((*EventSetOffline)(nil), "decimal.validator.v1.EventSetOffline")
	proto.RegisterType((*EventDelegate)(nil), "decimal.validator.v1.EventDelegate")
	proto.RegisterType((*EventRedelegate)(nil), "decimal.validator.v1.EventRedelegate")
	proto.RegisterType((*EventRedelegateComplete)(nil), "decimal.validator.v1.EventRedelegateComplete")
	proto.RegisterType((*EventUndelegate)(nil), "decimal.validator.v1.EventUndelegate")
	proto.RegisterType((*EventUndelegateComplete)(nil), "decimal.validator.v1.EventUndelegateComplete")
	proto.RegisterType((*EventCancelRedelegation)(nil), "decimal.validator.v1.EventCancelRedelegation")
	proto.RegisterType((*EventCancelUndelegation)(nil), "decimal.validator.v1.EventCancelUndelegation")
	proto.RegisterType((*EventUpdateValidator)(nil), "decimal.validator.v1.EventUpdateValidator")
	proto.RegisterType((*EventDelegatedCoinsUpdate)(nil), "decimal.validator.v1.EventDelegatedCoinsUpdate")
	proto.RegisterType((*EventEmission)(nil), "decimal.validator.v1.EventEmission")
	proto.RegisterType((*EventPayRewards)(nil), "decimal.validator.v1.EventPayRewards")
	proto.RegisterType((*EventLiveness)(nil), "decimal.validator.v1.EventLiveness")
	proto.RegisterType((*EventSlash)(nil), "decimal.validator.v1.EventSlash")
	proto.RegisterType((*ValidatorReward)(nil), "decimal.validator.v1.ValidatorReward")
	proto.RegisterType((*DelegatorReward)(nil), "decimal.validator.v1.DelegatorReward")
	proto.RegisterType((*StakeReward)(nil), "decimal.validator.v1.StakeReward")
	proto.RegisterType((*ValidatorSlash)(nil), "decimal.validator.v1.ValidatorSlash")
	proto.RegisterType((*DelegatorSlash)(nil), "decimal.validator.v1.DelegatorSlash")
	proto.RegisterType((*UndelegateSlash)(nil), "decimal.validator.v1.UndelegateSlash")
	proto.RegisterType((*RedelegateSlash)(nil), "decimal.validator.v1.RedelegateSlash")
	proto.RegisterType((*SlashCoin)(nil), "decimal.validator.v1.SlashCoin")
	proto.RegisterType((*SlashNFT)(nil), "decimal.validator.v1.SlashNFT")
	proto.RegisterType((*SlashNFTSubToken)(nil), "decimal.validator.v1.SlashNFTSubToken")
}

func init() { proto.RegisterFile("decimal/validator/v1/events.proto", fileDescriptor_060d365471b9fb1d) }

var fileDescriptor_060d365471b9fb1d = []byte{
	// 1402 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0xdf, 0x6f, 0xdb, 0xd4,
	0x17, 0xaf, 0x9d, 0x1f, 0x6b, 0x4f, 0x9a, 0x66, 0xb2, 0xfa, 0xdd, 0x37, 0xdb, 0xa4, 0xa4, 0x35,
	0x63, 0x0c, 0xa1, 0xda, 0xb4, 0x88, 0xdf, 0x4c, 0xb0, 0xb4, 0x9d, 0x28, 0x1b, 0xa3, 0x38, 0x1d,
	0x0f, 0x08, 0x11, 0x39, 0xf6, 0x6d, 0x6a, 0x12, 0xfb, 0x46, 0xbe, 0x37, 0xd9, 0x06, 0xe2, 0x15,
	0x4d, 0x3c, 0xa0, 0xbd, 0x20, 0x78, 0xdc, 0xbf, 0x80, 0xb4, 0xbf, 0x80, 0x87, 0x69, 0x0f, 0x48,
	0x4c, 0x93, 0x90, 0x10, 0x48, 0x05, 0x75, 0x2f, 0x48, 0xfc, 0x13, 0xe8, 0x5e, 0xdf, 0x38, 0xb6,
	0x95, 0xa5, 0xad, 0x33, 0x55, 0xaa, 0xf6, 0x94, 0xdc, 0xeb, 0x73, 0xce, 0x3d, 0xe7, 0x73, 0x3e,
	0xe7, 0xf8, 0x5c, 0xc3, 0xa2, 0x8d, 0x2c, 0xc7, 0x35, 0x3b, 0x7a, 0xdf, 0xec, 0x38, 0xb6, 0x49,
	0xb1, 0xaf, 0xf7, 0x97, 0x75, 0xd4, 0x47, 0x1e, 0x25, 0x5a, 0xd7, 0xc7, 0x14, 0x2b, 0xf3, 0x42,
	0x44, 0x0b, 0x45, 0xb4, 0xfe, 0xf2, 0x99, 0xf9, 0x16, 0x6e, 0x61, 0x2e, 0xa0, 0xb3, 0x7f, 0x81,
	0xec, 0x99, 0x6a, 0x0b, 0xe3, 0x56, 0x07, 0xe9, 0x7c, 0xd5, 0xec, 0x6d, 0xeb, 0xd4, 0x71, 0x11,
	0xa1, 0xa6, 0xdb, 0x15, 0x02, 0xa7, 0x2d, 0x4c, 0x5c, 0x4c, 0x1a, 0x81, 0x66, 0xb0, 0x10, 0x8f,
	0x2a, 0xc1, 0x4a, 0x6f, 0x9a, 0x04, 0xe9, 0xfd, 0xe5, 0x26, 0xa2, 0xe6, 0xb2, 0x6e, 0x61, 0xc7,
	0x13, 0xcf, 0xcf, 0x8d, 0x74, 0x75, 0xe8, 0x14, 0x97, 0x52, 0x7f, 0xc9, 0xc0, 0xfc, 0x3a, 0x73,
	0x7f, 0xd5, 0x47, 0x26, 0x45, 0x9f, 0x0c, 0x1e, 0x2b, 0x2f, 0x43, 0x9e, 0x20, 0xcf, 0x46, 0x7e,
	0x59, 0x5a, 0x90, 0x2e, 0xcc, 0xd4, 0xca, 0x8f, 0xee, 0x2d, 0xcd, 0x0b, 0x07, 0x2e, 0xd9, 0xb6,
	0x8f, 0x08, 0xa9, 0x53, 0xdf, 0xf1, 0x5a, 0x86, 0x90, 0x53, 0x5e, 0x83, 0x99, 0xd0, 0x7a, 0x59,
	0xde, 0x47, 0x69, 0x28, 0xaa, 0xbc, 0x0b, 0x73, 0x3e, 0xba, 0x61, 0xfa, 0x76, 0xc3, 0x0c, 0x44,
	0xca, 0x99, 0x7d, 0x94, 0x8b, 0x81, 0xbc, 0xd8, 0x54, 0x5e, 0x84, 0x93, 0x16, 0xf6, 0x08, 0xf2,
	0x48, 0x8f, 0x34, 0xba, 0xbd, 0x66, 0x1b, 0xdd, 0x2a, 0x67, 0x99, 0x09, 0xa3, 0x14, 0xee, 0x6f,
	0xf2, 0x6d, 0x65, 0x03, 0x0a, 0x36, 0x22, 0x96, 0xef, 0x74, 0xa9, 0x83, 0xbd, 0x72, 0x6e, 0x41,
	0xba, 0x50, 0x58, 0x59, 0xd4, 0x46, 0xa5, 0x4c, 0x5b, 0x1b, 0x0a, 0xd6, 0xb2, 0x0f, 0x76, 0xab,
	0x53, 0x46, 0x54, 0x57, 0xf9, 0x0c, 0xc0, 0xc2, 0xae, 0xeb, 0x10, 0xc2, 0x2c, 0xe5, 0xb9, 0xcb,
	0xef, 0x30, 0xb1, 0x3f, 0x76, 0xab, 0xe7, 0x5b, 0x0e, 0xdd, 0xe9, 0x35, 0x35, 0x0b, 0xbb, 0x22,
	0x69, 0xe2, 0x67, 0x89, 0xd8, 0x6d, 0x9d, 0xde, 0xea, 0x22, 0xa2, 0xad, 0x21, 0xeb, 0xd1, 0xbd,
	0x25, 0x10, 0x01, 0xae, 0x21, 0xcb, 0x88, 0xd8, 0x53, 0x5e, 0x85, 0x1c, 0xa1, 0x66, 0x1b, 0x95,
	0x4f, 0x70, 0x17, 0x4f, 0x6b, 0x42, 0x8e, 0x65, 0x5b, 0x13, 0xd9, 0xd6, 0x56, 0xb1, 0x33, 0x70,
	0x2d, 0x90, 0x56, 0xbf, 0x95, 0x41, 0xe1, 0xe9, 0x5c, 0xb7, 0x1d, 0x7a, 0x2c, 0x93, 0x99, 0xc8,
	0x50, 0x36, 0x7d, 0x86, 0xd4, 0x2f, 0x61, 0x8e, 0x63, 0x51, 0x47, 0xf4, 0x23, 0xaf, 0xe3, 0x78,
	0xe8, 0xe8, 0x70, 0x50, 0xbf, 0x82, 0x52, 0x78, 0xf6, 0xf6, 0xf6, 0x11, 0x1f, 0xfe, 0x8d, 0x0c,
	0x45, 0x7e, 0xfa, 0x1a, 0xea, 0xa0, 0x96, 0x49, 0x11, 0xb3, 0x64, 0x07, 0xff, 0xf1, 0xfe, 0xc7,
	0x0f, 0x45, 0x53, 0xd3, 0xe0, 0xf5, 0x01, 0x7d, 0x33, 0x3c, 0x7f, 0x67, 0x47, 0xe7, 0xaf, 0xce,
	0x44, 0x62, 0x04, 0x56, 0xae, 0x42, 0xc1, 0x74, 0x71, 0xcf, 0xa3, 0x0d, 0xc6, 0xf4, 0xa0, 0x8c,
	0x6b, 0x2f, 0x89, 0xb2, 0xfa, 0x5f, 0x70, 0x2c, 0xb1, 0xdb, 0x9a, 0x83, 0x75, 0xd7, 0xa4, 0x3b,
	0xda, 0x86, 0x47, 0x23, 0x55, 0xb4, 0xe1, 0x51, 0x03, 0x02, 0xfd, 0x9a, 0x49, 0x90, 0xfa, 0x7d,
	0x46, 0xa4, 0xc1, 0x40, 0xf6, 0xa4, 0x50, 0x5c, 0x84, 0x62, 0xe8, 0x7c, 0x83, 0xf8, 0xd6, 0xbe,
	0x70, 0xcc, 0x86, 0xe2, 0x75, 0xdf, 0x8a, 0xab, 0xdb, 0x84, 0xee, 0x5b, 0x17, 0x43, 0xf5, 0x35,
	0x42, 0x87, 0x80, 0x66, 0x27, 0x03, 0x34, 0x37, 0x11, 0xa0, 0xca, 0x3a, 0x14, 0x2c, 0xec, 0x76,
	0x3b, 0x88, 0xa2, 0x86, 0x49, 0x79, 0xd7, 0x2b, 0xac, 0x9c, 0xd1, 0x82, 0xd7, 0x98, 0x36, 0x78,
	0x8d, 0x69, 0x5b, 0x83, 0xd7, 0x58, 0x6d, 0x9a, 0x9d, 0x74, 0xe7, 0xaf, 0xaa, 0xc4, 0xbb, 0x1b,
	0x57, 0xbc, 0x44, 0xd5, 0xdb, 0x32, 0xfc, 0x3f, 0x91, 0x97, 0x55, 0xf1, 0xf4, 0x19, 0xcb, 0x8f,
	0xfa, 0xab, 0x2c, 0x28, 0x7a, 0xdd, 0xb3, 0x9f, 0xed, 0x6a, 0x4d, 0x92, 0x2b, 0x97, 0x92, 0x5c,
	0x3f, 0x4b, 0x82, 0x5c, 0x43, 0x44, 0x27, 0x26, 0xd7, 0x51, 0x23, 0xab, 0xfe, 0x34, 0xa8, 0x90,
	0x55, 0xd3, 0xb3, 0x50, 0x27, 0xac, 0x13, 0x36, 0x1b, 0x1c, 0xcf, 0x0a, 0x79, 0x01, 0x4a, 0x16,
	0x9b, 0x31, 0x1d, 0xec, 0x35, 0x76, 0x90, 0xd3, 0xda, 0xa1, 0x9c, 0x2f, 0x19, 0x63, 0x6e, 0xb0,
	0xfd, 0x3e, 0xdf, 0x1d, 0x62, 0x96, 0x3b, 0x24, 0x66, 0xff, 0x4a, 0x31, 0xcc, 0xc2, 0xf4, 0x4f,
	0x82, 0x59, 0xda, 0xc4, 0x8f, 0x88, 0x36, 0x33, 0x3e, 0xda, 0xc3, 0x36, 0x8e, 0x3f, 0x25, 0x31,
	0xb9, 0x5f, 0xef, 0xda, 0xb1, 0xc9, 0x3d, 0xe6, 0xb2, 0x74, 0x70, 0x97, 0xdf, 0x80, 0x3c, 0xa1,
	0x26, 0xed, 0x11, 0x1e, 0xe7, 0xdc, 0xca, 0xc2, 0x68, 0x57, 0x6a, 0xd8, 0xb3, 0xeb, 0x5c, 0xce,
	0x10, 0xf2, 0xca, 0x29, 0xc8, 0x63, 0x3e, 0x60, 0xf1, 0x18, 0xa7, 0x0d, 0xb1, 0x62, 0xfb, 0x5f,
	0x98, 0x4e, 0x07, 0xd9, 0x3c, 0xb8, 0x69, 0x43, 0xac, 0x94, 0x45, 0x98, 0xed, 0x63, 0xea, 0x78,
	0xad, 0x46, 0x17, 0xdf, 0x40, 0x3e, 0x4f, 0x74, 0xd6, 0x28, 0x04, 0x7b, 0x9b, 0x6c, 0x4b, 0x3d,
	0x0b, 0xa7, 0x63, 0x13, 0x8c, 0xcd, 0x66, 0x5d, 0x12, 0x84, 0xaa, 0x6e, 0x89, 0xf1, 0x66, 0x7d,
	0x30, 0x2d, 0xaf, 0x42, 0x3e, 0xe8, 0x23, 0x22, 0xde, 0x43, 0xb5, 0x20, 0xa1, 0xaa, 0x7e, 0x2e,
	0x1a, 0xf1, 0xa6, 0x79, 0xcb, 0xe0, 0x23, 0x29, 0x51, 0xae, 0x00, 0x84, 0xb1, 0x93, 0xb2, 0xb4,
	0x90, 0xb9, 0x50, 0x58, 0x79, 0x7e, 0x34, 0x2c, 0x21, 0xfe, 0x81, 0xae, 0xc8, 0x55, 0x44, 0x5d,
	0xfd, 0x41, 0x12, 0x6e, 0x5f, 0x75, 0xfa, 0xc8, 0x63, 0xb3, 0x6e, 0xda, 0x4c, 0x8d, 0xba, 0xf0,
	0xc8, 0xa3, 0x2f, 0x3c, 0xcf, 0x41, 0x91, 0x81, 0x84, 0xec, 0x46, 0xb3, 0x83, 0xad, 0x76, 0x30,
	0x8e, 0x17, 0x8d, 0xd9, 0x60, 0xb3, 0xc6, 0xf7, 0xd4, 0x3b, 0x12, 0x40, 0x30, 0xad, 0x76, 0x4c,
	0xb2, 0x93, 0xda, 0xad, 0x0f, 0x00, 0xc2, 0xc2, 0x61, 0x24, 0x62, 0x68, 0x9d, 0x7b, 0xd2, 0xe4,
	0x2e, 0xe4, 0xf8, 0x89, 0x03, 0xb0, 0x86, 0xda, 0xea, 0xfd, 0x0c, 0x94, 0x12, 0x90, 0xa6, 0xf6,
	0xeb, 0x22, 0x64, 0x6c, 0x13, 0x8b, 0xea, 0x3d, 0x14, 0x35, 0x98, 0x9e, 0xb2, 0x0e, 0x27, 0x6c,
	0xd4, 0x47, 0x1d, 0xdc, 0x15, 0x1d, 0xef, 0x50, 0x26, 0x06, 0xba, 0x8c, 0x4b, 0x91, 0xfb, 0x62,
	0x9a, 0x57, 0x65, 0xe4, 0x7a, 0xf8, 0x21, 0x14, 0x4c, 0xcb, 0xea, 0xb9, 0xbd, 0x0e, 0xab, 0x8d,
	0x34, 0x53, 0x5d, 0x54, 0x9f, 0xf9, 0x16, 0xc9, 0x5c, 0x7e, 0x1c, 0xcf, 0xc3, 0xcc, 0xc5, 0x79,
	0x3e, 0x54, 0x7f, 0x6b, 0xf6, 0xf6, 0xdd, 0xea, 0xd4, 0x8f, 0x77, 0xab, 0xd2, 0x3f, 0x77, 0xab,
	0x53, 0xac, 0x4d, 0x95, 0x12, 0x3a, 0x13, 0xbc, 0xc0, 0x72, 0x16, 0x6b, 0x03, 0x82, 0x5b, 0x8b,
	0x63, 0x7a, 0x65, 0xcc, 0xbb, 0x40, 0x4b, 0x59, 0x85, 0xac, 0xb7, 0x4d, 0x59, 0x09, 0x1c, 0x50,
	0x7b, 0x96, 0x69, 0xef, 0xed, 0x56, 0xb3, 0xd7, 0x2e, 0x6f, 0x11, 0x83, 0x2b, 0x27, 0xa2, 0xbb,
	0x09, 0x85, 0x88, 0x82, 0x72, 0x0a, 0x64, 0xc7, 0x16, 0x11, 0xe5, 0xf7, 0x76, 0xab, 0xf2, 0xc6,
	0x9a, 0x21, 0x3b, 0x36, 0xeb, 0x4f, 0xc1, 0x2d, 0x37, 0x0d, 0x09, 0x85, 0x6a, 0xe2, 0xe4, 0x07,
	0x32, 0xcc, 0x85, 0x05, 0xf2, 0x34, 0xeb, 0x36, 0x3f, 0x49, 0xdd, 0x2a, 0x1f, 0x43, 0xb1, 0x17,
	0x79, 0xef, 0x92, 0xf2, 0x89, 0x71, 0x64, 0x1a, 0x4e, 0x68, 0x51, 0x7b, 0x71, 0x0b, 0xcc, 0xa4,
	0x8f, 0xa2, 0x26, 0xa7, 0xc7, 0x99, 0x1c, 0xde, 0x28, 0x62, 0x26, 0x63, 0x16, 0x12, 0x50, 0xfe,
	0x26, 0xc1, 0x5c, 0x3c, 0xb0, 0xd4, 0x0c, 0x7d, 0x3b, 0xce, 0xd0, 0xea, 0x13, 0x38, 0xc6, 0xce,
	0x88, 0x7e, 0xbc, 0x09, 0xf8, 0xf9, 0x5e, 0x8c, 0x9f, 0x95, 0x31, 0xba, 0xd7, 0x2e, 0x6f, 0x1d,
	0x80, 0x9c, 0xdf, 0xc9, 0x50, 0x4a, 0x20, 0x7c, 0xe4, 0x73, 0x50, 0x08, 0x48, 0x66, 0x02, 0x40,
	0xb2, 0x4f, 0x09, 0x90, 0xfb, 0x32, 0x94, 0x12, 0xfc, 0x38, 0xa6, 0xc3, 0x74, 0x08, 0x6b, 0x76,
	0x02, 0x58, 0x73, 0x69, 0x61, 0x55, 0x37, 0x61, 0x26, 0xb4, 0xcd, 0x3f, 0x55, 0xb2, 0x05, 0x47,
	0xef, 0x40, 0x9f, 0x2a, 0x99, 0x74, 0x22, 0x35, 0x5f, 0xc3, 0xf4, 0xe0, 0xc4, 0x27, 0x76, 0xd1,
	0x2b, 0x00, 0xa4, 0xd7, 0x6c, 0x50, 0xdc, 0x46, 0x61, 0x85, 0x9d, 0x1f, 0xef, 0x7d, 0xbd, 0xd7,
	0xdc, 0x62, 0xe2, 0xe2, 0xe8, 0x19, 0x22, 0xd6, 0x49, 0x66, 0x60, 0x38, 0x99, 0x54, 0x89, 0xb8,
	0x51, 0x8c, 0xb9, 0x11, 0xc6, 0x2b, 0xa7, 0x8f, 0xb7, 0x56, 0x7f, 0xb0, 0x57, 0x91, 0x1e, 0xee,
	0x55, 0xa4, 0xbf, 0xf7, 0x2a, 0xd2, 0x9d, 0xc7, 0x95, 0xa9, 0x87, 0x8f, 0x2b, 0x53, 0xbf, 0x3f,
	0xae, 0x4c, 0x7d, 0xfa, 0x66, 0xd3, 0xa1, 0xcd, 0x9e, 0xd5, 0x46, 0x54, 0xc3, 0x7e, 0x4b, 0x17,
	0xe1, 0x51, 0x64, 0xba, 0x7a, 0x0b, 0x2f, 0x11, 0xd7, 0xf4, 0xe9, 0x92, 0x87, 0x6d, 0xa4, 0xdf,
	0x8c, 0x7c, 0xd9, 0xe7, 0x9f, 0x94, 0x9b, 0x79, 0x7e, 0x47, 0x7e, 0xe5, 0xbf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x95, 0xf1, 0xa5, 0xcf, 0xa6, 0x18, 0x00, 0x00,
}

func (m *EventCreateValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreateValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreateValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ConsensusPubkey) > 0 {
		i -= len(m.ConsensusPubkey)
		copy(dAtA[i:], m.ConsensusPubkey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ConsensusPubkey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RewardAddress) > 0 {
		i -= len(m.RewardAddress)
		copy(dAtA[i:], m.RewardAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RewardAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEditValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEditValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEditValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RewardAddress) > 0 {
		i -= len(m.RewardAddress)
		copy(dAtA[i:], m.RewardAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RewardAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetOnline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetOnline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetOnline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetOffline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetOffline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetOffline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountBase.Size()
		i -= size
		if _, err := m.AmountBase.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRedelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRedelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRedelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CompleteAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CompleteAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintEvents(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x32
	{
		size := m.AmountBase.Size()
		i -= size
		if _, err := m.AmountBase.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ValidatorDst) > 0 {
		i -= len(m.ValidatorDst)
		copy(dAtA[i:], m.ValidatorDst)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorDst)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorSrc) > 0 {
		i -= len(m.ValidatorSrc)
		copy(dAtA[i:], m.ValidatorSrc)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorSrc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRedelegateComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRedelegateComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRedelegateComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ValidatorDst) > 0 {
		i -= len(m.ValidatorDst)
		copy(dAtA[i:], m.ValidatorDst)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorDst)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorSrc) > 0 {
		i -= len(m.ValidatorSrc)
		copy(dAtA[i:], m.ValidatorSrc)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorSrc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventUndelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUndelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUndelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CompleteAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CompleteAt):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintEvents(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x2a
	{
		size := m.AmountBase.Size()
		i -= size
		if _, err := m.AmountBase.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventUndelegateComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUndelegateComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUndelegateComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelRedelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelRedelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelRedelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.CreationHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CreationHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ValidatorDst) > 0 {
		i -= len(m.ValidatorDst)
		copy(dAtA[i:], m.ValidatorDst)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorDst)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorSrc) > 0 {
		i -= len(m.ValidatorSrc)
		copy(dAtA[i:], m.ValidatorSrc)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorSrc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.CreationHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CreationHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventUpdateValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUpdateValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUpdateValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VotingPower != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x28
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Online {
		i--
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDelegatedCoinsUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDelegatedCoinsUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDelegatedCoinsUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EventEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPayRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPayRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPayRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventLiveness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLiveness) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLiveness) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MissedBlocks != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MissedBlocks))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ConsensusPubkey) > 0 {
		i -= len(m.ConsensusPubkey)
		copy(dAtA[i:], m.ConsensusPubkey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ConsensusPubkey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delegators) > 0 {
		for iNdEx := len(m.Delegators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delegators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delegators) > 0 {
		for iNdEx := len(m.Delegators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delegators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size := m.Accumulated.Size()
		i -= size
		if _, err := m.Accumulated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Develop.Size()
		i -= size
		if _, err := m.Develop.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Dao.Size()
		i -= size
		if _, err := m.Dao.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NFTs) > 0 {
		for iNdEx := len(m.NFTs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NFTs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakeReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Reward.Size()
		i -= size
		if _, err := m.Reward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Redelegations) > 0 {
		for iNdEx := len(m.Redelegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Redelegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Undelegations) > 0 {
		for iNdEx := len(m.Undelegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Undelegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Delegators) > 0 {
		for iNdEx := len(m.Delegators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delegators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegatorSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NFTs) > 0 {
		for iNdEx := len(m.NFTs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NFTs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NFTs) > 0 {
		for iNdEx := len(m.NFTs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NFTs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedelegateSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedelegateSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedelegateSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NFTs) > 0 {
		for iNdEx := len(m.NFTs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NFTs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidatorDst) > 0 {
		i -= len(m.ValidatorDst)
		copy(dAtA[i:], m.ValidatorDst)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorDst)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorSrc) > 0 {
		i -= len(m.ValidatorSrc)
		copy(dAtA[i:], m.ValidatorSrc)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorSrc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashCoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashCoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Slash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SlashNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubTokens) > 0 {
		for iNdEx := len(m.SubTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashNFTSubToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashNFTSubToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashNFTSubToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Slash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventCreateValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.RewardAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ConsensusPubkey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Description.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Commission.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventEditValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.RewardAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Description.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventSetOnline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSetOffline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.AmountBase.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventRedelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorSrc)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorDst)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.AmountBase.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CompleteAt)
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventRedelegateComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorSrc)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorDst)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventUndelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.AmountBase.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CompleteAt)
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventUndelegateComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventCancelRedelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorSrc)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorDst)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.CreationHeight != 0 {
		n += 1 + sovEvents(uint64(m.CreationHeight))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventCancelUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.CreationHeight != 0 {
		n += 1 + sovEvents(uint64(m.CreationHeight))
	}
	l = m.Stake.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventUpdateValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.Online {
		n += 2
	}
	if m.Jailed {
		n += 2
	}
	if m.VotingPower != 0 {
		n += 1 + sovEvents(uint64(m.VotingPower))
	}
	return n
}

func (m *EventDelegatedCoinsUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EventEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventPayRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventLiveness) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ConsensusPubkey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MissedBlocks != 0 {
		n += 1 + sovEvents(uint64(m.MissedBlocks))
	}
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Delegators) > 0 {
		for _, e := range m.Delegators {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *ValidatorReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Dao.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Develop.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Commission.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Accumulated.Size()
	n += 1 + l + sovEvents(uint64(l))
	if len(m.Delegators) > 0 {
		for _, e := range m.Delegators {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *DelegatorReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.NFTs) > 0 {
		for _, e := range m.NFTs {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *StakeReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Reward.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *ValidatorSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Delegators) > 0 {
		for _, e := range m.Delegators {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.Undelegations) > 0 {
		for _, e := range m.Undelegations {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.Redelegations) > 0 {
		for _, e := range m.Redelegations {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *DelegatorSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.NFTs) > 0 {
		for _, e := range m.NFTs {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *UndelegateSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.NFTs) > 0 {
		for _, e := range m.NFTs {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *RedelegateSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorSrc)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ValidatorDst)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.NFTs) > 0 {
		for _, e := range m.NFTs {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *SlashCoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Slash.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *SlashNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.SubTokens) > 0 {
		for _, e := range m.SubTokens {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *SlashNFTSubToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovEvents(uint64(m.ID))
	}
	l = m.Slash.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventCreateValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreateValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreateValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEditValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEditValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEditValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetOnline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetOnline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetOnline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetOffline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetOffline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetOffline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRedelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRedelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRedelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSrc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSrc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorDst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CompleteAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRedelegateComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRedelegateComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRedelegateComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSrc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSrc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorDst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUndelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUndelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUndelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CompleteAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUndelegateComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUndelegateComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUndelegateComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelRedelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelRedelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelRedelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSrc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSrc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorDst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationHeight", wireType)
			}
			m.CreationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationHeight", wireType)
			}
			m.CreationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUpdateValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUpdateValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUpdateValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BondStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDelegatedCoinsUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDelegatedCoinsUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDelegatedCoinsUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPayRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPayRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPayRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, ValidatorReward{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLiveness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLiveness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLiveness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedBlocks", wireType)
			}
			m.MissedBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedBlocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegators = append(m.Delegators, DelegatorSlash{})
			if err := m.Delegators[len(m.Delegators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dao", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dao.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Develop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Develop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accumulated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Accumulated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegators = append(m.Delegators, DelegatorReward{})
			if err := m.Delegators[len(m.Delegators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, StakeReward{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NFTs = append(m.NFTs, StakeReward{})
			if err := m.NFTs[len(m.NFTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegators = append(m.Delegators, DelegatorSlash{})
			if err := m.Delegators[len(m.Delegators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Undelegations = append(m.Undelegations, UndelegateSlash{})
			if err := m.Undelegations[len(m.Undelegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redelegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redelegations = append(m.Redelegations, RedelegateSlash{})
			if err := m.Redelegations[len(m.Redelegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, SlashCoin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NFTs = append(m.NFTs, SlashNFT{})
			if err := m.NFTs[len(m.NFTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, SlashCoin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NFTs = append(m.NFTs, SlashNFT{})
			if err := m.NFTs[len(m.NFTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedelegateSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedelegateSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedelegateSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSrc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSrc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorDst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorDst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, SlashCoin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NFTs = append(m.NFTs, SlashNFT{})
			if err := m.NFTs[len(m.NFTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Slash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubTokens = append(m.SubTokens, SlashNFTSubToken{})
			if err := m.SubTokens[len(m.SubTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashNFTSubToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashNFTSubToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashNFTSubToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Slash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
